<!DOCTYPE html>
<html lang="en">
	<head>
		<title>ќзеро —ветлое</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				text-align:center;
				padding: 5px;
			}

			a {

				color: #a06851;
			}

		</style>
	</head>
	<body>

		<div id="info">ќзеро —ветлое - прибрежна€ территори€</div>

		<script src="../build/three.min.js"></script>

		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/Mirror.js"></script>
		<script src="js/WaterShader.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script src="js/loaders/MTLLoader.js"></script>
		<script src="js/loaders/OBJMTLLoader.js"></script>
		
		<!-- ShaderParticles -->
		<script type="text/javascript" src="js/ShaderParticleEngine/ShaderParticleUtils.js"></script>
		<script type="text/javascript" src="js/ShaderParticleEngine/ShaderParticleGroup.js"></script>
		<script type="text/javascript" src="js/ShaderParticleEngine/ShaderParticleEmitter.js"></script>	
	
		<script>


			THREE.Path.prototype.moveToVector = function ( vector ) {

				this.moveTo( vector.x, vector.y );

			};

			THREE.Path.prototype.lineToVector = function ( vector ) {

				this.lineTo( vector.x, vector.y );

			};
					
		
			if ( ! Detector.webgl ) {

				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";

			}

			var container, stats;
			var camera, scene, renderer;

			        // Used in initParticles()
			var emitter, particleGroup;
			var clock = new THREE.Clock();
			
			var parameters = {
				width: 2000,
				height: 2000,
				widthSegments: 250,
				heightSegments: 250,
				depth: 1500,
				param: 4,
				filterparam: 1
			}
			
			var waterNormals;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 0.5, 3000000 );
				camera.position.set( 0, 4000, 12000 );

				//camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 10000);
				//camera.position.z = 50;
				//camera.lookAt( scene.position );
			
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.userPan = false;
				controls.userPanSpeed = 0.0;
				controls.maxDistance = 25000.0;
				controls.maxPolarAngle = Math.PI * 0.495;
				controls.center.set( 0, 500, 0 );

				var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
				light.position.set( - 1, 1, - 1 );
				scene.add( light );

				
				//------------------ load skybox ------------------ //

				
				var cubeMap = new THREE.CubeTexture( [] );
				cubeMap.format = THREE.RGBFormat;
				cubeMap.flipY = false;

				var loader = new THREE.ImageLoader();
				loader.load( 'textures/skyboxsun25degtest.png', function ( image ) {

					var getSide = function ( x, y ) {

						var size = 1024;

						var canvas = document.createElement( 'canvas' );
						canvas.width = size;
						canvas.height = size;

						var context = canvas.getContext( '2d' );
						context.drawImage( image, - x * size, - y * size );

						return canvas;

					};

					cubeMap.images[ 0 ] = getSide( 2, 1 ); // px
					cubeMap.images[ 1 ] = getSide( 0, 1 ); // nx
					cubeMap.images[ 2 ] = getSide( 1, 0 ); // py
					cubeMap.images[ 3 ] = getSide( 1, 2 ); // ny
					cubeMap.images[ 4 ] = getSide( 1, 1 ); // pz
					cubeMap.images[ 5 ] = getSide( 3, 1 ); // nz
					cubeMap.needsUpdate = true;

				} );

				var cubeShader = THREE.ShaderLib['cube'];
				cubeShader.uniforms['tCube'].value = cubeMap;

				var skyBoxMaterial = new THREE.ShaderMaterial( {
					fragmentShader: cubeShader.fragmentShader,
					vertexShader: cubeShader.vertexShader,
					uniforms: cubeShader.uniforms,
					depthWrite: false,
					side: THREE.BackSide
				});

				var skyBox = new THREE.Mesh(
					new THREE.BoxGeometry( 1000000, 1000000, 1000000 ),
					skyBoxMaterial
				);
				
				scene.add( skyBox );


				//------------------ load bright lake ------------------ //
				
				
				waterNormals = new THREE.ImageUtils.loadTexture( 'textures/waternormals.jpg' );
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping; 

				water = new THREE.Water( renderer, camera, scene, {
					textureWidth: 512, 
					textureHeight: 512,
					waterNormals: waterNormals,
					alpha: 	1.0,
					sunDirection: light.position.clone().normalize(),
					sunColor: 0xffffff,
					waterColor: 0x001e0f,
					distortionScale: 50.0,
				} );


				// California

				var californiaPts = [], vectors=[];
					vectors[0] = new THREE.Vector3(247,-101);
					vectors[1] = new THREE.Vector3(200,-70);
					vectors[2] = new THREE.Vector3(148,-35);
					vectors[3] = new THREE.Vector3(103,2);
					vectors[4] = new THREE.Vector3(65,33);
					vectors[5] = new THREE.Vector3(26,55);
					vectors[6] = new THREE.Vector3(-10,73);
					vectors[7] = new THREE.Vector3(-51,103);
					vectors[8] = new THREE.Vector3(-69,145);
					vectors[9] = new THREE.Vector3(-60,188);
					vectors[10] = new THREE.Vector3(-87,203);
					vectors[11] = new THREE.Vector3(-148,213);
					vectors[12] = new THREE.Vector3(-181,186);
					vectors[13] = new THREE.Vector3(-215,145);
					vectors[14] = new THREE.Vector3(-238,110);
					vectors[15] = new THREE.Vector3(-240,66);
					vectors[16] = new THREE.Vector3(-235,17);
					vectors[17] = new THREE.Vector3(-223,-18);
					vectors[18] = new THREE.Vector3(-192,-51);
					vectors[19] = new THREE.Vector3(-127,-87);
					vectors[20] = new THREE.Vector3(-52,-91);
					vectors[21] = new THREE.Vector3(-20,-94);
					vectors[22] = new THREE.Vector3(21,-108);
					vectors[23] = new THREE.Vector3(54,-124);
					vectors[24] = new THREE.Vector3(87,-156);
					vectors[25] = new THREE.Vector3(119,-187);
					vectors[26] = new THREE.Vector3(149,-213);
					vectors[27] = new THREE.Vector3(186,-214);
					vectors[28] = new THREE.Vector3(203,-201);
					vectors[29] = new THREE.Vector3(224,-155);
				
				for ( var i = 0; i < vectors.length; i++ ) {

					californiaPts.push( vectors[i] );

				}				


				for( var i = 0; i < californiaPts.length; i ++ ) californiaPts[ i ].multiplyScalar( 20 );

				var californiaShape = new THREE.Shape( californiaPts );
					//var geometry = new THREE.ShapeGeometry( californiaShape );
					//var mirrorMesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { side: THREE.DoubleSide } ) );
					
					//mirrorMesh.position.set( 0, 0, 0 );
					//mirrorMesh.rotation.x = -Math.PI/2;
					//mirrorMesh.rotation.z = -Math.PI/2;					

				var extrMaterial = new THREE.MeshBasicMaterial({
						color: 0xffffff,
						side: THREE.DoubleSide
				});				

				var extrudeSettings = { 
					amount: 16, 
					bevelSegments: 8, 
					curveSegments: 32, 
					material: 0, 
					extrudeMaterial: 1 
				};

				var geometry = new THREE.ExtrudeGeometry( californiaShape, extrudeSettings );
				water.material.transparent = false;
				var materials = [water.material, extrMaterial];
				var material = new THREE.MeshFaceMaterial(materials);
				
				//var material = new THREE.MeshBasicMaterial( { color: 0x0000ff, side: THREE.DoubleSide, transparent: false, opacity: 0.5 } );

				var mesh = new THREE.Mesh( geometry, material );

				mesh.rotation.x = -Math.PI/2;
				mesh.position.set( -450, -400, 1200 );
				mesh.add( water );
				scene.add( mesh );
							
				
				//mirrorMesh.add( water );
				//mirrorMesh.rotation.x = - Math.PI * 0.5
				//mirrorMesh.position.set( -4000, 20, 0 );
				//scene.add( mirrorMesh );






				var scale = 20;
				var sqWidth = scale * 926; 
				var sqHight = scale * 1081;
	
	
				var squareShape = new THREE.Shape();
				squareShape.moveTo(0, 0);
				squareShape.lineTo(sqWidth, 0); // <=========== counterClockwise widing order.
				squareShape.lineTo(sqWidth, sqHight);
				squareShape.lineTo(0, sqHight);
				squareShape.closePath();


				var CirclePath = new THREE.Path();
				var biasX = 1300; var biasY = 2100;
				var vector = new THREE.Vector2( vectors[0].x + sqWidth/2-biasX,  vectors[0].y + sqHight/2-biasY ).multiplyScalar( 1.1 );
				CirclePath.moveToVector(vector);
				
				for ( var i = 1; i < vectors.length; i++ ) {

					var vector = new THREE.Vector2( vectors[i].x + sqWidth/2-biasX,  vectors[i].y + sqHight/2-biasY ).multiplyScalar( 1.1 );
					CirclePath.lineToVector(vector);

				}					
				CirclePath.closePath();
				squareShape.holes.push(CirclePath);
				
				var Texture = new THREE.ImageUtils.loadTexture( 'textures/city3.png' );
				Texture.wrapS = Texture.wrapT = THREE.RepeatWrapping;
				Texture.repeat.set(1 / (sqWidth), 1 / ( sqHight));
				var material = new THREE.MeshBasicMaterial({
					map: Texture
				});


				var extrMaterial = new THREE.MeshLambertMaterial({
						color: 0x6B8E23,
						side: THREE.DoubleSide
				});

					
				var ExtrTexture = THREE.ImageUtils.loadTexture( 'textures/extrmtr.jpg' );
				ExtrTexture.wrapS = ExtrTexture.wrapT= THREE.RepeatWrapping;

				ExtrTexture.offset.set( 0, 0.2 );
				ExtrTexture.repeat.set( 0, 0.0001 );

				var extrMaterial = new THREE.MeshBasicMaterial( { map: ExtrTexture } );
	
									
				
				var materials = [material, extrMaterial];
				var material = new THREE.MeshFaceMaterial(materials);
					
				var heightShore = 400, amount = 160;
				var extrudeSettings = { 
					amount: amount, 
					bevelSegments: 8, 
					curveSegments: 32,
					bevelEnabled: true,
					bevelThickness: heightShore,
					bevelSize: 600,
					material: 0, 
					extrudeMaterial: 1 
				};
				
				var geometry = new THREE.ExtrudeGeometry(squareShape, extrudeSettings);
				var mesh = new THREE.Mesh(geometry, material);

				mesh.position.set(-sqWidth/2, -heightShore - amount, sqHight/2);
				mesh.rotation.x = -Math.PI/2;
				scene.add(mesh);			
							
				/*
				var geometry = new THREE.ShapeGeometry( squareShape );
				geometry.faceUvs = [
					[]
				];
				geometry.faceVertexUvs = [
					[]
				];				
								
				for (var f = 0; f < geometry.faces.length; f++) {

					var faceuv = [
						new THREE.Vector2(0, 1),
						new THREE.Vector2(1, 1),
						new THREE.Vector2(1, 0),
						new THREE.Vector2(0, 0)
					];

					geometry.faceUvs[0].push(new THREE.Vector2(0, 1));
					geometry.faceVertexUvs[0].push(faceuv);
				}

				var Texture = new THREE.ImageUtils.loadTexture( 'textures/city.png' );
				Texture.wrapS = THREE.RepeatWrapping;
				Texture.wrapT = THREE.RepeatWrapping;
				Texture.repeat.set( 1, 1 );
				
					var mesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { map: Texture, side: THREE.DoubleSide } ) );
					
					mesh.position.set( 0, 0, 0 );
					mesh.rotation.x = -Math.PI/2;
					scene.add( mesh );
			*/
				
				
				var geometry = new THREE.PlaneGeometry( sqWidth, sqHight, 10, 10 );
				var material = new THREE.MeshLambertMaterial( { map: new THREE.ImageUtils.loadTexture( 'textures/city.png' ), side: THREE.DoubleSide, transparent: false, opacity: 0.6  } );

				Plane = new THREE.Mesh( geometry, material );
				Plane.position.set( 0, -5, 0 ); Plane.rotation.x = -Math.PI/2;
			//	scene.add( Plane );

				
				//------------------ load Fountan ------------------ //				
			
			
			initParticles( -2000, -320, 1000 );
	
			var geometry = new THREE.TorusGeometry( 120, 80, 36, 36 );
				var material = new THREE.MeshPhongMaterial( { color: 0x00BFFF, shininess: 300 } );
				var disk = new THREE.Mesh( geometry, material );
					disk.rotation.x = Math.PI / 2;
					disk.position.set( -2000, -350, 1000 );
					scene.add( disk );

	
				//------------------ load volleyball ------------------ //	
			var geometry = new THREE.Geometry;
			var material = new THREE.LineBasicMaterial( { color: 0x8B4726 } );

			geometry.vertices.push( new THREE.Vector3( -1000, 0, 0 ) ); 
			geometry.vertices.push( new THREE.Vector3( -1000, 500, 0 ) ); 
			geometry.vertices.push( new THREE.Vector3( 1000, 500, 0 ) ); 			
			geometry.vertices.push( new THREE.Vector3( 1000, 0, 0 ) ); 
			geometry.vertices.push( new THREE.Vector3( 1000, 300, 0 ) ); 
			geometry.vertices.push( new THREE.Vector3( -1000, 300, 0 ) ); 
			
			var line = new THREE.Line( geometry, material );
			line.scale.x = 1/1.85;
			line.position.set( 4568, 0, -780 );
			line.rotation.y = Math.PI / 2.8;
			scene.add( line );

			
				//------------------ load GRID ------------------ //
				
			var gridLen = 20000;
            gridCount = 1000;
            var gridXZ = new THREE.GridHelper(gridLen, gridCount);
            gridXZ.setColors(new THREE.Color(0xD3D3D3), new THREE.Color(0xD3D3D3));
            gridXZ.position.set(0, 10, 0);
            //scene.add(gridXZ);
			


	
	
            // Update cube map once the texture is loaded
            // to avoid extra payload when updating it on each frame
            treeTexture = THREE.ImageUtils.loadTexture(
                'textures/tree.png'
                //new THREE.UVMapping(),
               // updateCubeMap
            );

            var tree = new THREE.Sprite(new THREE.SpriteMaterial({
                map: treeTexture,
                useScreenCoordinates: false
            }));
			
			tree.scale.set(1000, 1000, 1);
            tree.position.set(-9000, 400, 10000);
            scene.add(tree);
			
			for (var i=0; i<5; i++) {
				for (var j=0; j<5-i; j++) {
				
					var mesh = tree.clone();
					mesh.position.set(-9000+1000*i, 400, 10000 - 1000 * j);
					scene.add(mesh);			
				}
			}
			
			var pos = []; 
				for (var i=0; i<5; i++) {	
				
						var vector = new THREE.Vector3( -6000, 300, -5500 + 1000 * i );
						pos.push( vector );
				
				}			

				for (var i=0; i<5; i++) {	
				
						var vector = new THREE.Vector3( -7000, 300, -5500 + 1000 * i ); 
						pos.push( vector );
				}
				
				for (var i=0; i<3; i++) {	
				
						var vector = new THREE.Vector3( -6000, 300, 1500 + 1000 * i ); 
						pos.push( vector );
				}	
				
				for (var i=0; i<2; i++) {	
				
						var vector = new THREE.Vector3( -7000, 300, 1500 + 1000 * i ); 
						pos.push( vector );
				}

				for (var i=0; i<3; i++) {	
				
						var vector = new THREE.Vector3( -5000, 300, 2500 + 1000 * i ); 
						pos.push( vector );
				}
				
				for (var i=0; i<3; i++) {	
				
						var vector = new THREE.Vector3( -4000, 300, 3250 + 1000 * i ); 
						pos.push( vector );
				}	
				
				for (var i=0; i<3; i++) {	
				
						var vector = new THREE.Vector3( -3000, 300, 3750 + 1000 * i ); 
						pos.push( vector );
				}					
				
				for (var i=0; i<pos.length; i++) {
				
						var mesh = tree.clone();
						mesh.position.copy(pos[i]);
						scene.add(mesh);			

				}	
			


		
				//------------------ load exterior ------------------ //			
			var loader = new THREE.OBJMTLLoader(); // лоадер
			loader.load( 'models/busStation/busStation.obj', 'models/busStation/busStation.mtl', 
				function ( busStation ) {
					busStation.scale.set(3, 3, 3);
					busStation.position.set( -6500, 100, 0 );	
					busStation.rotation.y = -Math.PI/2;					
					scene.add( busStation );
				}
			);		
			

				
			


			loader.load( 'models/tent/tent.obj', 'models/tent/tent.mtl', 
				function ( tent ) {
					tent.scale.set(3, 3, 3);
					tent.position.set( -1500, 300, -2000 );			
					scene.add( tent );
				}
			);	
			
		
			
			
			loader.load( 'models/bridge/bridge3.obj', 'models/bridge/bridge3.mtl', 
				function ( bridge3 ) {
					bridge3.scale.set(1/2, 1/2, 2/3);
					bridge3.position.set( 1500, 0, 1400 );
					bridge3.rotation.y = -Math.PI/6;
					bridge3.rotation.x = Math.PI/6;
					bridge3.rotation.z = Math.PI/12;					
					scene.add( bridge3 );
				}
			);	



			
		

	
			loader.load( 'models/arbor/arbor.obj', 'models/arbor/arbor.mtl', 
				function ( arbor ) {
					arbor.position.set( -500, 0, -1500 );	
					scene.add( arbor );
				}
			);
			

			loader.load( 'models/playground/playground.obj', 'models/playground/playground.mtl', 
				function ( playground ) {
					playground.scale.set(1/4, 1/4, 1/4);
					playground.position.set( -1000, 0, -5000 );	
					scene.add( playground );
				}
			);	
		
					
			loader.load( 'models/hexagonalBench/hexagonalBench.obj', 'models/hexagonalBench/hexagonalBench.mtl', 
				function ( hexagonalBench ) {
					hexagonalBench.scale.set(4, 4, 4);
					hexagonalBench.position.set( 2000, 0, -2000 );	
					scene.add( hexagonalBench );
				}
			);	
			
			


			loader.load( 'models/outdoorBench/outdoorBench.obj', 'models/outdoorBench/outdoorBench.mtl', 
				function ( outdoorBench ) {
					outdoorBench.scale.set(2, 2, 2);
					outdoorBench.position.set( 2000, 0, -500 );
					outdoorBench.rotation.y = Math.PI+Math.PI/3;					
					scene.add( outdoorBench );

					var mesh = outdoorBench.clone();
					scene.add( mesh );
					mesh.position.set( 3000, 0, 0 );

					var mesh = outdoorBench.clone();
					scene.add( mesh );
					mesh.position.set( 4000, 0, 500 );	

					var mesh = outdoorBench.clone();
					scene.add( mesh );
					mesh.position.set( 5000, 0, 1000 );
					
				}
			);	
			

			loader.load( 'models/urn/urn.obj', 'models/urn/urn.mtl', 
				function ( urn ) {
					urn.scale.set(4, 4, 4);
					urn.position.set( 2500, 0, -500 );	
					scene.add( urn );
					
					var mesh = urn.clone();
					scene.add( mesh );
					mesh.position.set( 3500, 0, 0 );
					
					var mesh = urn.clone();
					scene.add( mesh );
					mesh.position.set( 4500, 0, 500 );	
					
					var mesh = urn.clone();
					scene.add( mesh );
					mesh.position.set( 5500, 0, 1000 );
		
					
				}
			);


/*
		
			

			loader.load( 'models/tree/tree1.obj', 'models/tree/tree1.mtl', 
				function ( tree ) {
					tree.scale.set(2, 2, 2);
					tree.position.set( -6000, 0, -2000 );			
					scene.add( tree );
					
					var mesh = tree.clone();
					scene.add( mesh );
					mesh.position.set( -6000, 0, -1000 );

					var mesh = tree.clone();
					scene.add( mesh );
					mesh.position.set( -6000, 0, 0 );
	
					var mesh = tree.clone();
					scene.add( mesh );
					mesh.position.set( -6000, 0, 1000 );


					
				}
			);	
			
			
			loader.load( 'models/tree/tree2.obj', 'models/tree/tree2.mtl', 
				function ( tree ) {
					tree.scale.set(3, 3, 3);
					tree.position.set( -1600, 300, -2000 );			
					scene.add( tree );
				}
			);	
			
			loader.load( 'models/tree/tree3.obj', 'models/tree/tree3.mtl', 
				function ( tree ) {
					tree.scale.set(3, 3, 3);
					tree.position.set( -2200, 300, -2000 );			
					scene.add( tree );
				}
			);	
	
			loader.load( 'models/fountain/fountain.obj', 'models/fountain/fountain.mtl', 
				function ( fountain ) {
					fountain.scale.set(2, 2, 2);
					fountain.position.set( -250, 0, -220 );	
					//scene.add( fountain );
				}
			);	
			
			loader.load( 'models/bridge/bridge.obj', 'models/bridge/bridge.mtl', 
				function ( bridge ) {
					//bridge.scale.set(1/2, 1/2, 1/2);
					bridge.position.set( 1500, 0, -1200 );	
					//scene.add( bridge );
				}
			);	
  newmtl название_материала1   # ќбъ€вление очередного материала
  # ÷вета
  Ka 1,000 1,000 0,000         # ÷вет окружающего освещени€ (желтый)
  Kd 1,000 1,000 1,000         # ƒиффузный цвет (белый)
  # ѕараметры отражени€
  Ks 0,000 0,000 0,000         # ÷вет зеркального отражени€ (0;0;0 - выключен)
  Ns 10,000                    #  оэффициент зеркального отражени€ (от 0 до 1000)
  # ѕараметры прозрачности
  d 0,9                        # ѕрозрачность указываетс€ с помощью директивы d
  Tr 0,9                       #   или в других реализаци€х формата с помощью Tr
  #—ледующий материал
  newmtl название_материала2
  ...	

Х map_Ka -  “екстура
Х map_Kd -  ƒиффузна€ текстура
Х map_Ks -  Specular
Х map_Ns -  Specular highlight
Х map_d - Alpha
Х map_bump - название говорит само за себ€ Bump.
Х map_Ke -  Emission - самосвечение (или собственное излучение).  
	*/		
			}

			//

        function initParticles( x, y, z ) {
        	particleGroup = new SPE.Group({
        		texture: THREE.ImageUtils.loadTexture('textures/smokeparticle.png'),
        		maxAge: 2
        	});

        	emitter = new SPE.Emitter({
        		position: new THREE.Vector3( x, y, z ),
                positionSpread: new THREE.Vector3( 0, 0, 0 ),

        		acceleration: new THREE.Vector3(0, -10, 0).multiplyScalar(50),
        		accelerationSpread: new THREE.Vector3( 10, 0, 10 ).multiplyScalar(50),

        		velocity: new THREE.Vector3(0, 15, 0).multiplyScalar(50),
        		velocitySpread: new THREE.Vector3(10, 7.5, 10).multiplyScalar(50),

        		colorStart: new THREE.Color('white'),
        		colorEnd: new THREE.Color('red'),

        		sizeStart: 1,
        		sizeEnd: 1,
				opacityStart: 1,
                opacityEnd: 1,
        		particleCount: 3000
        	});

        	particleGroup.addEmitter( emitter );
        	scene.add( particleGroup.mesh );

        	//document.querySelector('.numParticles').textContent =
        		//'Total particles: ' + emitter.particleCount;
        }			
			
			
			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				var time = performance.now() * 0.001;

				water.material.uniforms.time.value += 1.0 / 60.0;
				controls.update();
				water.render();		
				
				renderParticle( clock.getDelta() );				
				renderer.render( scene, camera );


			}
			
			function renderParticle( dt ) {
				particleGroup.tick( dt );
			}			

		</script>
	</body>
</html>
